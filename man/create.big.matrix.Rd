% Generated by roxygen2 (4.1.0.9001): do not edit by hand
% Please edit documentation in R/normalize-samples.r
\name{create.big.matrix}
\alias{create.big.matrix}
\title{We use \code{\link[parallel]{mclapply}()} to reduce running time by taking advantage of the fact
that each sample can be normalized independently of the others.
Unfortuantely \code{\link[parallel]{mclapply}()} has two important limitations.
The size in memory of the list returned may be at most 2Gb otherwise
\code{\link[parallel]{mclapply}()} fails with the following error message:
   Error in sendMaster(try(lapply(X = S, FUN = FUN, ...), silent = TRUE)) :
   long vectors not supported ...}
\usage{
create.big.matrix(norm.objects, sites, type, filename = NULL)
}
\description{
A non-elegant solution to this problem is to guess the size of each element
in the returned list and then apply \code{\link[parallel]{mclapply}()} sequentially to a sequence
appropriately sized input subsets.
A solution for \code{lapply} is to allocate the final object (e.g. a matrix)
prior to calling \code{lapply} and then populate the object during
the call to \code{lapply} using the global assignment operator '<<-'.
Unfortunately this is not a solution for \code{\link[parallel]{mclapply}()}
because \code{\link[parallel]{mclapply}()} immediately
duplicates the object, applies any modifications to the duplicate
and then deletes it prior to completion losing all modifications.
I'm not sure why the duplicate is not copied onto the original.
Fortunately, this is a solution if the object is a \code{\link{bigmemory::big.matrix}},
and we use it here.
}

