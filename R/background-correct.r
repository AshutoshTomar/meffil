
#' Background correction
#'
#' Background correct Cy5/Cy3 signal of a Infinium HumanMethylation450 BeadChip.
#'
#' @param rg Cy5/Cy3 signal generated by \code{\link{meffil.read.rg}()}.
#' @param probes Probe annotation used to construct the control matrix
#' (Default: \code{\link{meffil.probe.info}()}).
#' @param offset Number to add to background corrected signal (Default: 15).
#' @param verbose If \code{TRUE}, then status messages are printed during execution (Default: \code{FALSE}).
#' @return Background corrected Cy5/Cy3 signal by \code{\link[limma]{normexp.signal}}.
#'
#' @export
meffil.background.correct <- function(rg, probes=meffil.probe.info(), offset=15, verbose=F) {
    stopifnot(is.rg(rg))

    lapply(c(R="R",G="G"), function(dye) {
        msg("background correction for dye =", dye, verbose=verbose)
        addresses <- probes$address[which(probes$target %in% c("M","U") & probes$dye == dye)]
        xf <- rg[[dye]][addresses]
        xf[which(xf <= 0)] <- 1

        addresses <- probes$address[which(probes$type == "control" & probes$dye == dye)]
        xc <- rg[[dye]][addresses]
        xc[which(xc <= 0)] <- 1

        addresses <- probes$address[which(probes$target == "OOB" & probes$dye == dye)]
        oob <- rg[[dye]][addresses]

        ests <- MASS::huber(oob)
        mu <- ests$mu
        sigma <- log(ests$s)
        alpha <- log(max(MASS::huber(xf)$mu - mu, 10))
        bg <- limma::normexp.signal(as.numeric(c(mu,sigma,alpha)), c(xf,xc)) + offset
        names(bg) <- c(names(xf), names(xc))
        bg
    })
}
